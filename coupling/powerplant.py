#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Feb 12 15:17:46 2018

@author: witte
"""

# %% imports

import pandas as pd
import numpy as np
import json
from scipy import interpolate

from tespy import nwkr

# %% power plant model class


class model:
    """
    creates a model of a power plant

    :param path: path to power plant: data.json
    :type path: str
    :returns: no return value
    """

    def __init__(self, cd):

        # load data.json information into objects dictionary (= attributes of
        # the object)
        path = (cd.working_dir + cd.powerplant_path + cd.scenario +
                '.powerplant_ctrl.json')
        wdir = cd.working_dir + cd.powerplant_path
        with open(path) as f:
            self.__dict__.update(json.load(f))

        self.tespy_charge_path = wdir + self.tespy_charge_path
        self.tespy_discharge_path = wdir + self.tespy_discharge_path
        self.spline_charge_path = wdir + self.spline_charge_path
        self.spline_discharge_path = wdir + self.spline_discharge_path
        # load tespy models with the network_reader module
        self.tespy_charge = nwkr.load_nwk(self.tespy_charge_path)
        self.tespy_charge.set_printoptions(print_level='err')
        self.tespy_discharge = nwkr.load_nwk(self.tespy_discharge_path)
        self.tespy_discharge.set_printoptions(print_level='err')

        # load splines from .csv data
        self.spline_charge = self.load_lookup(self.spline_charge_path)
        self.spline_discharge = self.load_lookup(self.spline_discharge_path)

    def get_mass_flow(self, power, pressure, mode):
        """
        calculates the mass flow at given power and pressure in charging or
        discharging mode

        :param power: turbine or compressor power
        :type power: float
        :param pressure: interface pressure
        :type pressure: float
        :param mode: calculate mass flow for charging or discharging
        :type mode: str
        :returns: mass flow (float) - value for mass flow
        :raises: - :code:`ValueError`, mode is neither charge nor discharge
                 - :code:`ValueError`, if calculation method is not specified
         """

        # these parts look ugly, I have to come up with ideas, how to
        # access specific connections/components/busses generated by the
        # network_reader module -> not a priority!
        if self.method == 'tespy':
            if mode == 'charge':
                init_file = self.tespy_charge_path + '/results.csv'
                # set power of bus
                self.tespy_charge.busses[0].set_attr(P=power)
                # set pressure at interface
                if hasattr(self, 'cas_charge'):
                    self.cas_charge.set_attr(p=pressure)
                    self.cas_charge.set_attr(m=np.nan)
                else:
                    for c in self.tespy_charge.conns.index:
                        if c.t.label == 'cas':
                            self.cas_charge = c
                            self.cas_charge.set_attr(p=pressure)
                            self.cas_charge.set_attr(m=np.nan)
                            break
                try:
                    self.tespy_charge.solve(mode='offdesign',
                                            init_file=init_file,
                                            design_file=init_file)
                except:
                    print('ERROR: Could not find a solution for input pair: '
                          'P=' + str(power) + ' p=' + str(pressure))
                    return 0

                return self.cas_charge.m.val_SI

            elif mode == 'discharge':
                init_file = self.tespy_discharge_path + '/results.csv'
                # set power of bus
                self.tespy_discharge.busses[0].set_attr(P=power)
                # set pressure at interface
                if hasattr(self, 'cas_discharge'):
                    self.cas_discharge.set_attr(p=pressure)
                    self.cas_discharge.set_attr(m=np.nan)
                else:
                    for c in self.tespy_discharge.conns.index:
                        if c.s.label == 'cas':
                            self.cas_discharge = c
                            self.cas_discharge.set_attr(p=pressure)
                            self.cas_discharge.set_attr(m=np.nan)
                            break

                try:
                    self.tespy_discharge.solve(mode='offdesign',
                                               init_file=init_file,
                                               design_file=init_file)
                except:
                    print('ERROR: Could not find a solution for input pair: '
                          'P=' + str(power) + ' p=' + str(pressure))
                    return 0

                return self.cas_discharge.m.val_SI

            else:
                raise ValueError('Mode must be charge or discharge.')

        elif self.method == 'spline':
            if mode == 'charge':
                func = self.spline_charge

            elif mode == 'discharge':
                func = self.spline_discharge
                power = -power
            else:
                raise ValueError('Mode must be charge or discharge.')

            mass_flow = newton(reverse_2d, reverse_2d_deriv,
                               [func, pressure, power], 0)

            if mass_flow == 0:
                print('ERROR: Could not find a solution for input pair: '
                      'P=' + str(power) + ' p=' + str(pressure))

            return mass_flow

        else:
            raise ValueError('Method must be tespy or spline.')

    def get_power(self, mass_flow, pressure, mode):
        """
        calculates the power at given mass flow and pressure in charging or
        discharging mode

        :param mass_flow: mass flow from/to cas
        :type mass_flow: float
        :param pressure: interface pressure
        :type pressure: float
        :param mode: calculate mass flow for charging or discharging
        :type mode: str
        :returns: power (float) - total turbine/compressor power
        :raises: - :code:`ValueError`, mode is neither charge nor discharge
                 - :code:`ValueError`, if calculation method is not specified
         """

        if self.method == 'tespy':
            if mode == 'charge':
                init_file = self.tespy_charge_path + '/results.csv'
                self.tespy_charge.busses[0].set_attr(P=np.nan)
                # set mass flow and pressure at interface
                if hasattr(self, 'cas_charge'):
                    self.cas_charge.set_attr(p=pressure)
                    self.cas_charge.set_attr(m=mass_flow)
                else:
                    for c in self.tespy_charge.conns.index:
                        if c.t.label == 'cas':
                            self.cas_charge = c
                            self.cas_charge.set_attr(p=pressure)
                            self.cas_charge.set_attr(m=mass_flow)
                            break

                self.tespy_charge.solve(mode='offdesign',
                                        init_file=init_file,
                                        design_file=init_file)

                return self.tespy_charge.busses[0].P.val

            elif mode == 'discharge':
                init_file = self.tespy_discharge_path + '/results.csv'
                self.tespy_discharge.busses[0].set_attr(P=np.nan)
                # set mass flow and pressure at interface
                if hasattr(self, 'cas_discharge'):
                    self.cas_discharge.set_attr(p=pressure)
                    self.cas_discharge.set_attr(m=mass_flow)
                else:
                    for c in self.tespy_discharge.conns.index:
                        if c.s.label == 'cas':
                            self.cas_discharge = c
                            self.cas_discharge.set_attr(p=pressure)
                            self.cas_discharge.set_attr(m=mass_flow)
                            break

                self.tespy_discharge.solve(mode='offdesign',
                                           init_file=init_file,
                                           design_file=init_file)

                return self.tespy_discharge.busses[0].P.val

            else:
                raise ValueError('Mode must be charge or discharge.')

        elif self.method == 'spline':
            if mode == 'charge':
                return self.spline_charge.ev(mass_flow, pressure)

            elif mode == 'discharge':
                return self.spline_discharge.ev(mass_flow, pressure)

            else:
                raise ValueError('Mode must be charge or discharge.')
        else:
            raise ValueError('Method must be tespy or spline.')

    def load_lookup(self, path):
        """
        creates a rectangular bivariate spline object from data given in path

        :param path: path to .csv-file containing LUT's data
        :type path: str
        :returns: func (scipy.interpolate.RectBivariateSpline) - spline
                  interpolation object
         """
        df = pd.read_csv(path, index_col=0)

        y = df.as_matrix()  # power

        x1 = df.index.get_values()  # mass flow
        if x1[0] > x1[-1]:
            x1 = x1[::-1]
            y = y[::-1]
        x2 = np.array(list(map(float, list(df))))  # pressure
        if x2[0] > x2[-1]:
            x2 = x2[::-1]
            y = y[:, ::-1]

        func = interpolate.RectBivariateSpline(x1, x2, y)
        return func

# %% these parts are important for the spline lut!


def reverse_2d(params, y):
    r"""
    reverse function for lookup table

    :param params: variable function parameters
    :type params: list
    :param y: functional value, so that :math:`x_2 -
              f\left(x_1, y \right) = 0`
    :type y: float
    :returns: residual value of the function :math:`x_2 -
              f\left(x_1, y \right)`
    """
    func, x1, x2 = params[0], params[1], params[2]
    return x2 - func.ev(y, x1)


def reverse_2d_deriv(params, y):
    r"""
    derivative of the reverse function for a lookup table

    :param params: variable function parameters
    :type params: list
    :param y: functional value, so that :math:`x_2 -
              f\left(x_1, y \right) = 0`
    :type y: float
    :returns: partial derivative :math:`\frac{\partial f}{\partial y}`
    """
    func, x1 = params[0], params[1]
    return - func.ev(y, x1, dx=1)


def newton(func, deriv, params, k, **kwargs):
    r"""
    find zero crossings of function func with 1-D newton algorithm,
    required for reverse functions of fluid mixtures

    :param func: function to find zero crossing in
    :type func: function
    :param deriv: derivative of the function
    :type deriv: function
    :param params: vector containing parameters for func
    :type params: list
    :param k: target value for function func
    :type k: numeric
    :returns: val (float) - val, so that func(params, val) = k

    **allowed keywords** in kwargs:

    - val0 (*numeric*) - starting value
    - valmin (*numeric*) - minimum value
    - valmax (*numeric*) - maximum value
    - imax (*numeric*) - maximum number of iterations

    .. math::

        x_{i+1} = x_{i} - \frac{f(x_{i})}{\frac{df}{dx}(x_{i})}\\
        f(x_{n}) \leq \epsilon, \; n < 10\\
        n: \text{number of iterations}
    """

    # default valaues
    val = kwargs.get('val0', 200)
    valmin = kwargs.get('valmin', 0)
    valmax = kwargs.get('valmax', 3000)
    imax = kwargs.get('imax', 10)

    # start newton loop
    res = 1
    i = 0
    while abs(res) >= 1e-5:
        # calculate function residual
        res = k - func(params, val)
        # calculate new value
        val += res / deriv(params, val)

        # check for value ranges
        if val < valmin:
            val = valmin
        if val > valmax:
            val = valmax
        i += 1

        if i > imax:
            return 0

    return val
